var documenterSearchIndex = {"docs":
[{"location":"#LibNTL.jl","page":"Home","title":"LibNTL.jl","text":"Julia wrapper for the NTL (Number Theory Library) C++ library.","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"LibNTL.jl provides Julia bindings for NTL's core number-theoretic types:\n\nZZ: Arbitrary-precision integers\nZZ_p: Integers modulo p (modular arithmetic)\nZZX: Polynomials with integer coefficients\n\nAll types integrate seamlessly with Julia's type system and operators, providing an idiomatic experience for Julia users.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(\"LibNTL\")","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"using LibNTL\n\n# Arbitrary-precision integers\na = ZZ(42)\nb = ZZ(\"12345678901234567890\")\nc = a + b\nprintln(\"Sum: \", c)\n\n# Modular arithmetic\nZZ_p_init!(ZZ(17))  # Set modulus to 17\nx = ZZ_p(5)\ny = inv(x)  # Multiplicative inverse: 5 * 7 = 35 = 1 mod 17\nprintln(\"Inverse of 5 mod 17: \", rep(y))\n\n# Polynomials\nf = ZZX([ZZ(1), ZZ(2), ZZ(1)])  # 1 + 2x + x^2\nprintln(\"f(3) = \", f(ZZ(3)))","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"Full arithmetic support: Addition, subtraction, multiplication, division, exponentiation\nBigInt interoperability: Seamless conversion between ZZ and Julia's BigInt\nGCD and extended GCD: Including Bezout coefficients\nPolynomial operations: Derivative, content, primitive part, GCD\nThread-local modulus: Context-based modular arithmetic with save/restore\nCollection support: Use ZZ, ZZ_p, ZZX as keys in Dict and elements in Set","category":"section"},{"location":"#Contents","page":"Home","title":"Contents","text":"Pages = [\"types.md\", \"tutorial.md\"]","category":"section"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"This tutorial covers common usage patterns for LibNTL.jl.","category":"section"},{"location":"tutorial/#Basic-Usage","page":"Tutorial","title":"Basic Usage","text":"","category":"section"},{"location":"tutorial/#Arbitrary-Precision-Integers-(ZZ)","page":"Tutorial","title":"Arbitrary-Precision Integers (ZZ)","text":"using LibNTL\n\n# Create integers\na = ZZ(42)\nb = ZZ(\"12345678901234567890\")\nc = ZZ(big\"999999999999999999999999\")\n\n# Arithmetic\nsum = a + b\ndiff = b - a\nprod = a * b\nquot = div(b, a)\nremainder = rem(b, a)\n\n# Power\nsquared = a^2\nbig_power = ZZ(2)^1000  # 2^1000\n\n# GCD\ng = gcd(ZZ(48), ZZ(18))  # 6\nd, s, t = gcdx(ZZ(48), ZZ(18))  # d = 48*s + 18*t\n\n# Convert to/from BigInt\nbig_val = convert(BigInt, b)\nback_to_zz = ZZ(big_val)\n\n# Display\nprintln(a)  # 42\nprintln(\"Bits: \", numbits(b))  # Number of bits","category":"section"},{"location":"tutorial/#Modular-Arithmetic-(ZZ_p)","page":"Tutorial","title":"Modular Arithmetic (ZZ_p)","text":"using LibNTL\n\n# Set the modulus (must be > 1)\np = ZZ(17)\nZZ_p_init!(p)\n\n# Create elements mod p\nx = ZZ_p(5)\ny = ZZ_p(12)\n\n# Arithmetic (automatically reduced mod p)\nsum = x + y      # 0 (since 5 + 12 = 17 ≡ 0 mod 17)\nprod = x * y     # 9 (since 5 * 12 = 60 ≡ 9 mod 17)\n\n# Inverse\ninv_x = inv(x)   # 7 (since 5 * 7 = 35 ≡ 1 mod 17)\n\n# Power\npowered = x^10\n\n# Get underlying value\nval = rep(x)     # Returns ZZ in [0, p-1]\n\n# Check current modulus\nprintln(\"Modulus: \", ZZ_p_modulus())  # 17","category":"section"},{"location":"tutorial/#Context-Switching","page":"Tutorial","title":"Context Switching","text":"using LibNTL\n\n# Work with different moduli\nZZ_p_init!(ZZ(17))\na = ZZ_p(5)\n\n# Use with_modulus for temporary modulus change\nresult = with_modulus(ZZ(23)) do\n    b = ZZ_p(7)\n    inv(b)  # Inverse mod 23\nend\n\n# Original modulus is restored\nprintln(ZZ_p_modulus())  # 17","category":"section"},{"location":"tutorial/#Polynomials-over-Z-(ZZX)","page":"Tutorial","title":"Polynomials over Z (ZZX)","text":"using LibNTL\n\n# Create polynomials\nzero_poly = ZZX()              # 0\nconst_poly = ZZX(ZZ(5))        # 5\nlinear = ZZX([ZZ(1), ZZ(2)])   # 1 + 2x\n\n# Build polynomial by setting coefficients\nf = ZZX()\nsetcoeff!(f, 0, ZZ(1))   # constant term\nsetcoeff!(f, 2, ZZ(3))   # x^2 coefficient\nsetcoeff!(f, 4, ZZ(1))   # x^4 coefficient\n# f = 1 + 3x^2 + x^4\n\n# Query polynomial\nprintln(\"Degree: \", degree(f))        # 4\nprintln(\"Leading: \", leading(f))      # 1\nprintln(\"Constant: \", constant(f))    # 1\nprintln(\"Coeff of x^2: \", coeff(f, 2)) # 3\nprintln(\"Coeff of x^3: \", coeff(f, 3)) # 0 (not set)\n\n# Arithmetic\ng = ZZX([ZZ(1), ZZ(1)])  # 1 + x\nproduct = f * g\nsum = f + g\n\n# Division\nq, r = divrem(f, g)  # f = q*g + r\n\n# GCD\nh = gcd(f, g)\n\n# Evaluate polynomial\nx = ZZ(2)\nresult = f(x)  # 1 + 3*4 + 16 = 29\n\n# Derivative\ndf = derivative(f)  # 6x + 4x^3\n\n# Content and primitive part\nc = content(f)      # GCD of coefficients\npp = primpart(f)    # f / content(f)","category":"section"},{"location":"tutorial/#Common-Patterns","page":"Tutorial","title":"Common Patterns","text":"","category":"section"},{"location":"tutorial/#RSA-style-Modular-Exponentiation","page":"Tutorial","title":"RSA-style Modular Exponentiation","text":"using LibNTL\n\n# Generate a prime modulus\np = ZZ(\"104729\")  # A prime number\n\nZZ_p_init!(p)\n\n# Base and exponent\nbase = ZZ_p(12345)\nexponent = ZZ(\"1000000007\")\n\n# Modular exponentiation\nresult = base^exponent\n\nprintln(\"12345^1000000007 mod 104729 = \", rep(result))","category":"section"},{"location":"tutorial/#Polynomial-GCD","page":"Tutorial","title":"Polynomial GCD","text":"using LibNTL\n\n# f(x) = x^3 - 1 = (x-1)(x^2+x+1)\nf = ZZX([ZZ(-1), ZZ(0), ZZ(0), ZZ(1)])\n\n# g(x) = x^2 - 1 = (x-1)(x+1)\ng = ZZX([ZZ(-1), ZZ(0), ZZ(1)])\n\n# GCD should be (x-1) up to constant\nh = gcd(f, g)\nprintln(\"GCD: \", h)  # Should be proportional to (x - 1)","category":"section"},{"location":"tutorial/#Large-Integer-Factorization-Setup","page":"Tutorial","title":"Large Integer Factorization Setup","text":"using LibNTL\n\n# Check if a number might be prime\nn = ZZ(\"170141183460469231731687303715884105727\")  # 2^127 - 1 (Mersenne prime)\n\n# Count bits\nprintln(\"Bits: \", numbits(n))  # 127\n\n# Basic primality test via trial division up to small bound\nis_composite = false\nfor p in [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]\n    if rem(n, ZZ(p)) == ZZ(0) && n != ZZ(p)\n        is_composite = true\n        println(\"Divisible by \", p)\n        break\n    end\nend\n\nif !is_composite\n    println(\"Not divisible by small primes\")\nend","category":"section"},{"location":"tutorial/#Error-Handling","page":"Tutorial","title":"Error Handling","text":"using LibNTL\n\n# Division by zero\ntry\n    div(ZZ(10), ZZ(0))\ncatch e\n    println(\"Caught: \", e)  # DomainError\nend\n\n# Inverse of zero in ZZ_p\nZZ_p_init!(ZZ(17))\ntry\n    inv(ZZ_p(0))\ncatch e::InvModError\n    println(\"Cannot invert \", e.a, \" mod \", e.n)\nend","category":"section"},{"location":"tutorial/#Performance-Tips","page":"Tutorial","title":"Performance Tips","text":"Reuse objects: Avoid creating many small temporary ZZ values in tight loops\nPre-set modulus: Call ZZ_p_init! once before many ZZ_p operations\nUse with_modulus: For nested computations with different moduli\nPolynomial degree: Higher degree polynomials use FFT-based multiplication","category":"section"},{"location":"tutorial/#Comparison-with-Julia's-BigInt","page":"Tutorial","title":"Comparison with Julia's BigInt","text":"Operation LibNTL.ZZ Julia BigInt Notes\nCreation ZZ(...) big\"...\" Similar\nArithmetic Same operators Same operators ZZ uses NTL's optimized GMP wrapper\nModular ZZ_p type mod() function ZZ_p stores modulus context\nPolynomials Native ZZX Manual ZZX has built-in polynomial ops","category":"section"},{"location":"types/#Type-Reference","page":"Types","title":"Type Reference","text":"","category":"section"},{"location":"types/#ZZ-Arbitrary-Precision-Integers","page":"Types","title":"ZZ - Arbitrary-Precision Integers","text":"","category":"section"},{"location":"types/#Arithmetic","page":"Types","title":"Arithmetic","text":"ZZ supports all standard Julia arithmetic operators:\n\n+, -, *: Addition, subtraction, multiplication\n^: Power (non-negative integer exponents)\ndiv, rem, mod, divrem: Integer division operations\ngcd, gcdx: GCD and extended GCD","category":"section"},{"location":"types/#Conversion","page":"Types","title":"Conversion","text":"# From various types\nZZ(42)                    # From Int\nZZ(\"12345678901234567890\")  # From String\nZZ(big\"999999999999\")     # From BigInt\n\n# To other types\nBigInt(ZZ(42))            # To BigInt\nconvert(Int64, ZZ(42))    # To Int64 (throws if overflow)\nstring(ZZ(42))            # To String","category":"section"},{"location":"types/#Predicates","page":"Types","title":"Predicates","text":"iszero(z): Check if zero\nisone(z): Check if one\nisodd(z), iseven(z): Parity checks\nsign(z): Returns -1, 0, or 1","category":"section"},{"location":"types/#ZZ_p-Modular-Integers","page":"Types","title":"ZZ_p - Modular Integers","text":"","category":"section"},{"location":"types/#Modulus-Management","page":"Types","title":"Modulus Management","text":"Before using ZZ_p, you must set a modulus:\n\nZZ_p_init!(ZZ(17))  # All operations are now mod 17\n\nFor temporary modulus changes:\n\nwith_modulus(ZZ(23)) do\n    # Operations here use modulus 23\n    a = ZZ_p(20)\n    println(rep(a))  # 20\nend\n# Original modulus is restored","category":"section"},{"location":"types/#Arithmetic-2","page":"Types","title":"Arithmetic","text":"ZZ_p supports:\n\n+, -, *: Field operations\n/: Division (via multiplicative inverse)\n^: Power\ninv: Multiplicative inverse","category":"section"},{"location":"types/#ZZ_pContext","page":"Types","title":"ZZ_pContext","text":"For manual context management:\n\nctx = ZZ_pContext()\nsave!(ctx)        # Save current modulus\nZZ_p_init!(ZZ(31))  # Change modulus\n# ... work with modulus 31 ...\nrestore!(ctx)     # Restore previous modulus","category":"section"},{"location":"types/#ZZX-Polynomials-over-Z","page":"Types","title":"ZZX - Polynomials over Z","text":"","category":"section"},{"location":"types/#Construction","page":"Types","title":"Construction","text":"# From coefficient vector [a_0, a_1, ..., a_n]\nf = ZZX([ZZ(1), ZZ(2), ZZ(3)])  # 1 + 2x + 3x^2\n\n# From scalar (constant polynomial)\ng = ZZX(ZZ(5))  # 5\n\n# Zero polynomial\nh = ZZX()","category":"section"},{"location":"types/#Coefficient-Access","page":"Types","title":"Coefficient Access","text":"f = ZZX([ZZ(1), ZZ(2), ZZ(3)])\ndegree(f)     # 2\nf[0]          # ZZ(1) - constant term\nf[2]          # ZZ(3) - leading coefficient\nleading(f)    # ZZ(3)\nconstant(f)   # ZZ(1)","category":"section"},{"location":"types/#Arithmetic-3","page":"Types","title":"Arithmetic","text":"+, -, *: Polynomial arithmetic\nc * f, f * c: Scalar multiplication\ndiv, rem, divrem: Polynomial division\ngcd: Polynomial GCD","category":"section"},{"location":"types/#Polynomial-Operations","page":"Types","title":"Polynomial Operations","text":"f = ZZX([ZZ(1), ZZ(2), ZZ(3)])\n\n# Evaluation\nf(ZZ(5))  # Evaluate at x = 5\n\n# Derivative\nderivative(f)  # 2 + 6x\n\n# Content and primitive part\ng = ZZX([ZZ(6), ZZ(12), ZZ(18)])\ncontent(g)   # ZZ(6)\nprimpart(g)  # 1 + 2x + 3x^2","category":"section"},{"location":"types/#Iteration","page":"Types","title":"Iteration","text":"ZZX supports iteration over coefficients:\n\nf = ZZX([ZZ(1), ZZ(2), ZZ(3)])\nfor c in f\n    println(c)\nend\n# Output: 1, 2, 3","category":"section"},{"location":"types/#InvModError","page":"Types","title":"InvModError","text":"Thrown when computing a modular inverse fails:\n\nZZ_p_init!(ZZ(10))\ntry\n    inv(ZZ_p(5))  # 5 has no inverse mod 10\ncatch e::InvModError\n    println(\"Cannot invert \", e.a, \" mod \", e.n)\nend","category":"section"},{"location":"types/#LibNTL.ZZ","page":"Types","title":"LibNTL.ZZ","text":"ZZ\n\nArbitrary-precision integer type. In development mode, this is a wrapper around BigInt.\n\n\n\n\n\n","category":"type"},{"location":"types/#LibNTL.numbits","page":"Types","title":"LibNTL.numbits","text":"numbits(z::ZZ) -> Int\n\nReturn the number of bits in the binary representation of |z|. Returns 0 for z = 0.\n\n\n\n\n\n","category":"function"},{"location":"types/#LibNTL.numbytes","page":"Types","title":"LibNTL.numbytes","text":"numbytes(z::ZZ) -> Int\n\nReturn the number of bytes needed to represent |z|. Returns 0 for z = 0.\n\n\n\n\n\n","category":"function"},{"location":"types/#LibNTL.ZZ_p","page":"Types","title":"LibNTL.ZZ_p","text":"ZZ_p\n\nModular integer type. In development mode, this is a wrapper around ZZ.\n\n\n\n\n\n","category":"type"},{"location":"types/#LibNTL.ZZ_p_init!","page":"Types","title":"LibNTL.ZZ_p_init!","text":"ZZ_p_init!(p::ZZ)\n\nSet the global modulus for ZZ_p operations. Throws DomainError if p <= 1.\n\n\n\n\n\n","category":"function"},{"location":"types/#LibNTL.with_modulus","page":"Types","title":"LibNTL.with_modulus","text":"with_modulus(f::Function, p::ZZ)\n\nExecute function f with a temporary modulus p. The original modulus is restored after f completes.\n\n\n\n\n\n","category":"function"},{"location":"types/#LibNTL.rep","page":"Types","title":"LibNTL.rep","text":"rep(a::ZZ_p) -> ZZ\n\nGet the representative integer in [0, p-1] for a ZZ_p value.\n\n\n\n\n\n","category":"function"},{"location":"types/#LibNTL.save!","page":"Types","title":"LibNTL.save!","text":"save!(ctx::ZZ_pContext)\n\nSave the current modulus state into the context.\n\n\n\n\n\n","category":"function"},{"location":"types/#LibNTL.restore!","page":"Types","title":"LibNTL.restore!","text":"restore!(ctx::ZZ_pContext)\n\nRestore the modulus state from the context.\n\n\n\n\n\n","category":"function"},{"location":"types/#LibNTL.ZZX","page":"Types","title":"LibNTL.ZZX","text":"ZZX\n\nPolynomial over integers. In development mode, stores coefficients as Vector{ZZ}.\n\n\n\n\n\n","category":"type"},{"location":"types/#LibNTL.degree","page":"Types","title":"LibNTL.degree","text":"degree(f::ZZX) -> Int\n\nReturn the degree of the polynomial. Returns -1 for the zero polynomial.\n\n\n\n\n\n","category":"function"},{"location":"types/#LibNTL.coeff","page":"Types","title":"LibNTL.coeff","text":"coeff(f::ZZX, i::Integer) -> ZZ\n\nReturn the coefficient of x^i in f.\n\n\n\n\n\n","category":"function"},{"location":"types/#LibNTL.setcoeff!","page":"Types","title":"LibNTL.setcoeff!","text":"setcoeff!(f::ZZX, i::Integer, c::ZZ)\n\nSet the coefficient of x^i in f to c.\n\n\n\n\n\n","category":"function"},{"location":"types/#LibNTL.leading","page":"Types","title":"LibNTL.leading","text":"leading(f::ZZX) -> ZZ\n\nReturn the leading (highest degree) coefficient of f.\n\n\n\n\n\n","category":"function"},{"location":"types/#LibNTL.constant","page":"Types","title":"LibNTL.constant","text":"constant(f::ZZX) -> ZZ\n\nReturn the constant term (coefficient of x^0) of f.\n\n\n\n\n\n","category":"function"},{"location":"types/#LibNTL.derivative","page":"Types","title":"LibNTL.derivative","text":"derivative(f::ZZX) -> ZZX\n\nCompute the formal derivative of f.\n\n\n\n\n\n","category":"function"},{"location":"types/#LibNTL.content","page":"Types","title":"LibNTL.content","text":"content(f::ZZX) -> ZZ\n\nCompute the content (GCD of all coefficients) of f.\n\n\n\n\n\n","category":"function"},{"location":"types/#LibNTL.primpart","page":"Types","title":"LibNTL.primpart","text":"primpart(f::ZZX) -> ZZX\n\nCompute the primitive part (f / content(f)) of f.\n\n\n\n\n\n","category":"function"},{"location":"types/#LibNTL.InvModError","page":"Types","title":"LibNTL.InvModError","text":"InvModError(a::Any, n::Any)\n\nException thrown when computing a modular inverse fails because gcd(a, n) ≠ 1.\n\nFields\n\na: The value that failed to be inverted\nn: The modulus\n\nExample\n\ntry\n    inv(ZZ_p(0))\ncatch e::InvModError\n    println(\"Cannot invert \", e.a, \" mod \", e.n)\nend\n\n\n\n\n\n","category":"type"}]
}
