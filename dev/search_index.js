var documenterSearchIndex = {"docs":
[{"location":"examples/#NTL-Tour-Examples","page":"Examples","title":"NTL Tour Examples","text":"This page demonstrates LibNTL.jl by comparing NTL C++ examples with their Julia equivalents. All examples are from the NTL Tour.","category":"section"},{"location":"examples/#Tour-Example-1:-Big-Integers","page":"Examples","title":"Tour Example 1: Big Integers","text":"","category":"section"},{"location":"examples/#Example-1.1:-Basic-Arithmetic","page":"Examples","title":"Example 1.1: Basic Arithmetic","text":"C++ (NTL):\n\n#include <NTL/ZZ.h>\nusing namespace NTL;\n\nint main() {\n   ZZ a, b, c;\n   cin >> a >> b;\n   c = a + b;\n   cout << c << endl;\n}\n\nJulia (LibNTL.jl):\n\nusing LibNTL\n\na = ZZ(\"12345678901234567890\")\nb = ZZ(\"98765432109876543210\")\nc = a + b\nprintln(c)  # 111111111011111111100","category":"section"},{"location":"examples/#Example-1.2:-Sum-of-Squares","page":"Examples","title":"Example 1.2: Sum of Squares","text":"C++ (NTL):\n\nZZ sum = ZZ(0);\nfor (long i = 1; i <= 100; i++) {\n   sum += ZZ(i) * ZZ(i);\n}\n\nJulia (LibNTL.jl):\n\nusing LibNTL\n\nsum = ZZ(0)\nfor i in 1:100\n    sum += ZZ(i) * ZZ(i)\nend\nprintln(sum)  # 338350","category":"section"},{"location":"examples/#Example-1.3:-Modular-Exponentiation","page":"Examples","title":"Example 1.3: Modular Exponentiation","text":"C++ (NTL):\n\nZZ a, e, n;\nPowerMod(result, a, e, n);\n\nJulia (LibNTL.jl):\n\nusing LibNTL\n\na = ZZ(2)\ne = ZZ(100)\nn = ZZ(1000000007)\nresult = PowerMod(a, e, n)\nprintln(result)  # 976371285","category":"section"},{"location":"examples/#Example-1.4:-Primality-Testing","page":"Examples","title":"Example 1.4: Primality Testing","text":"C++ (NTL):\n\nZZ n;\nif (ProbPrime(n))\n   cout << n << \" is probably prime\" << endl;\n\nJulia (LibNTL.jl):\n\nusing LibNTL\n\nn = ZZ(\"170141183460469231731687303715884105727\")  # 2^127 - 1\nif ProbPrime(n)\n    println(\"$n is probably prime\")\nend","category":"section"},{"location":"examples/#Tour-Example-2:-Vectors-and-Matrices","page":"Examples","title":"Tour Example 2: Vectors and Matrices","text":"","category":"section"},{"location":"examples/#Example-2.1:-Vector-Sum-(0-indexed-style)","page":"Examples","title":"Example 2.1: Vector Sum (0-indexed style)","text":"C++ (NTL):\n\nVec<ZZ> v;\nv.SetLength(5);\nZZ sum = ZZ(0);\nfor (long i = 0; i < v.length(); i++)\n   sum += v[i];\n\nJulia (LibNTL.jl):\n\nusing LibNTL\n\nv = VecZZ([ZZ(1), ZZ(2), ZZ(3), ZZ(4), ZZ(5)])\nsum = ZZ(0)\nfor i in 0:length(v)-1\n    sum += v(i)  # 0-indexed access via callable\nend\nprintln(sum)  # 15","category":"section"},{"location":"examples/#Example-2.2:-Vector-Sum-(1-indexed-Julia-style)","page":"Examples","title":"Example 2.2: Vector Sum (1-indexed Julia style)","text":"Julia (LibNTL.jl):\n\nusing LibNTL\n\nv = VecZZ([ZZ(1), ZZ(2), ZZ(3), ZZ(4), ZZ(5)])\nsum = ZZ(0)\nfor x in v  # Iterator access\n    sum += x\nend\nprintln(sum)  # 15","category":"section"},{"location":"examples/#Example-2.3:-Matrix-Multiplication","page":"Examples","title":"Example 2.3: Matrix Multiplication","text":"C++ (NTL):\n\nMat<ZZ> A, B, C;\nmul(C, A, B);\n\nJulia (LibNTL.jl):\n\nusing LibNTL\n\nA = MatZZ(2, 2)\nA[1,1] = ZZ(1); A[1,2] = ZZ(2)\nA[2,1] = ZZ(3); A[2,2] = ZZ(4)\n\nB = MatZZ(2, 2)\nB[1,1] = ZZ(5); B[1,2] = ZZ(6)\nB[2,1] = ZZ(7); B[2,2] = ZZ(8)\n\nC = A * B\nprintln(\"C[1,1] = \", C[1,1])  # 19\nprintln(\"C[1,2] = \", C[1,2])  # 22\nprintln(\"C[2,1] = \", C[2,1])  # 43\nprintln(\"C[2,2] = \", C[2,2])  # 50","category":"section"},{"location":"examples/#Tour-Example-3:-Polynomials-over-Z","page":"Examples","title":"Tour Example 3: Polynomials over Z","text":"","category":"section"},{"location":"examples/#Example-3.1:-Polynomial-Factorization","page":"Examples","title":"Example 3.1: Polynomial Factorization","text":"C++ (NTL):\n\nZZX f;\nVec<Pair<ZZX, long>> factors;\nZZ c;\nfactor(c, factors, f);\n\nJulia (LibNTL.jl):\n\nusing LibNTL\n\n# x^4 - 1 = (x-1)(x+1)(x^2+1)\nf = ZZX([ZZ(-1), ZZ(0), ZZ(0), ZZ(0), ZZ(1)])\ncontent_val, factors = factor(f)\n\nprintln(\"Content: \", content_val)\nfor (poly, mult) in factors\n    println(\"Factor: \", poly, \" with multiplicity \", mult)\nend","category":"section"},{"location":"examples/#Example-3.2:-Cyclotomic-Polynomials","page":"Examples","title":"Example 3.2: Cyclotomic Polynomials","text":"C++ (NTL):\n\nZZX phi;\nCyclotomicPoly(phi, 12);  // Phi_12(x)\n\nJulia (LibNTL.jl):\n\nusing LibNTL\n\nphi = cyclotomic(12)  # Phi_12(x) = x^4 - x^2 + 1\nprintln(\"Phi_12(x) = \", phi)\nprintln(\"Degree: \", degree(phi))  # 4","category":"section"},{"location":"examples/#Tour-Example-4:-Modular-Polynomials","page":"Examples","title":"Tour Example 4: Modular Polynomials","text":"","category":"section"},{"location":"examples/#Example-4.1:-Polynomial-Factorization-mod-p","page":"Examples","title":"Example 4.1: Polynomial Factorization mod p","text":"C++ (NTL):\n\nZZ_p::init(ZZ(17));\nZZ_pX f;\n// Build f(x) = x^4 - 1\nSetCoeff(f, 4, 1);\nSetCoeff(f, 0, -1);\n\nJulia (LibNTL.jl):\n\nusing LibNTL\n\nwith_modulus(ZZ(17)) do\n    # x^4 - 1 = x^4 + 16 (mod 17)\n    f = ZZ_pX([ZZ_p(16), ZZ_p(0), ZZ_p(0), ZZ_p(0), ZZ_p(1)])\n    println(\"f(x) = \", f)\n\n    # Check roots\n    for x in 0:16\n        if iszero(f(ZZ_p(x)))\n            println(\"Root: \", x)\n        end\n    end\nend","category":"section"},{"location":"examples/#Example-4.2:-Irreducibility-Testing","page":"Examples","title":"Example 4.2: Irreducibility Testing","text":"C++ (NTL):\n\nZZ_p::init(ZZ(2));\nZZ_pX f;\n// f = x^2 + x + 1\nSetCoeff(f, 0, 1);\nSetCoeff(f, 1, 1);\nSetCoeff(f, 2, 1);\nif (DetIrredTest(f))\n   cout << \"Irreducible!\" << endl;\n\nJulia (LibNTL.jl):\n\nusing LibNTL\n\nwith_modulus(ZZ(2)) do\n    # x^2 + x + 1 is irreducible over GF(2)\n    f = ZZ_pX([ZZ_p(1), ZZ_p(1), ZZ_p(1)])\n    println(\"f = \", f)\n    println(\"Irreducible: \", is_irreducible(f))  # true\nend","category":"section"},{"location":"examples/#Example-4.3:-Context-Management","page":"Examples","title":"Example 4.3: Context Management","text":"C++ (NTL):\n\nZZ_p::init(ZZ(17));\nZZ_pContext context;\ncontext.save();\nZZ_p::init(ZZ(23));\n// ... work with modulus 23 ...\ncontext.restore();\n\nJulia (LibNTL.jl):\n\nusing LibNTL\n\nZZ_p_init!(ZZ(17))\nprintln(\"Outer modulus: \", ZZ_p_modulus())\n\nwith_modulus(ZZ(23)) do\n    println(\"Inner modulus: \", ZZ_p_modulus())\n    # Work with modulus 23\nend\n\nprintln(\"Restored modulus: \", ZZ_p_modulus())  # Back to 17","category":"section"},{"location":"examples/#Running-the-Examples","page":"Examples","title":"Running the Examples","text":"All examples are available as runnable scripts in the examples/ directory:\n\n# From the package directory\ninclude(\"examples/tour_ex1/basic_arithmetic.jl\")\ninclude(\"examples/tour_ex2/matrix_multiply.jl\")\ninclude(\"examples/tour_ex3/factorization.jl\")\ninclude(\"examples/tour_ex4/poly_factor_mod_p.jl\")\n\nOr run them as tests:\n\nusing Pkg\nPkg.test(\"LibNTL\")","category":"section"},{"location":"#LibNTL.jl","page":"Home","title":"LibNTL.jl","text":"Julia wrapper for the NTL (Number Theory Library) C++ library.","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"LibNTL.jl provides Julia bindings for NTL's core number-theoretic types:\n\nZZ: Arbitrary-precision integers\nZZ_p: Integers modulo p (modular arithmetic)\nZZX: Polynomials with integer coefficients\n\nAll types integrate seamlessly with Julia's type system and operators, providing an idiomatic experience for Julia users.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(\"LibNTL\")","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"using LibNTL\n\n# Arbitrary-precision integers\na = ZZ(42)\nb = ZZ(\"12345678901234567890\")\nc = a + b\nprintln(\"Sum: \", c)\n\n# Modular arithmetic\nZZ_p_init!(ZZ(17))  # Set modulus to 17\nx = ZZ_p(5)\ny = inv(x)  # Multiplicative inverse: 5 * 7 = 35 = 1 mod 17\nprintln(\"Inverse of 5 mod 17: \", rep(y))\n\n# Polynomials\nf = ZZX([ZZ(1), ZZ(2), ZZ(1)])  # 1 + 2x + x^2\nprintln(\"f(3) = \", f(ZZ(3)))","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"Full arithmetic support: Addition, subtraction, multiplication, division, exponentiation\nBigInt interoperability: Seamless conversion between ZZ and Julia's BigInt\nGCD and extended GCD: Including Bezout coefficients\nPolynomial operations: Derivative, content, primitive part, GCD, factorization\nModular polynomials: ZZ_pX with irreducibility testing\nVectors and matrices: VecZZ and MatZZ for linear algebra\nThread-local modulus: Context-based modular arithmetic with save/restore\nCollection support: Use ZZ, ZZ_p, ZZX as keys in Dict and elements in Set\nNTL Tour examples: Complete Julia translations of NTL tutorial examples","category":"section"},{"location":"#Contents","page":"Home","title":"Contents","text":"Pages = [\"types.md\", \"tutorial.md\", \"examples.md\"]","category":"section"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"This tutorial covers common usage patterns for LibNTL.jl.","category":"section"},{"location":"tutorial/#Basic-Usage","page":"Tutorial","title":"Basic Usage","text":"","category":"section"},{"location":"tutorial/#Arbitrary-Precision-Integers-(ZZ)","page":"Tutorial","title":"Arbitrary-Precision Integers (ZZ)","text":"using LibNTL\n\n# Create integers\na = ZZ(42)\nb = ZZ(\"12345678901234567890\")\nc = ZZ(big\"999999999999999999999999\")\n\n# Arithmetic\nsum = a + b\ndiff = b - a\nprod = a * b\nquot = div(b, a)\nremainder = rem(b, a)\n\n# Power\nsquared = a^2\nbig_power = ZZ(2)^1000  # 2^1000\n\n# GCD\ng = gcd(ZZ(48), ZZ(18))  # 6\nd, s, t = gcdx(ZZ(48), ZZ(18))  # d = 48*s + 18*t\n\n# Convert to/from BigInt\nbig_val = convert(BigInt, b)\nback_to_zz = ZZ(big_val)\n\n# Display\nprintln(a)  # 42\nprintln(\"Bits: \", numbits(b))  # Number of bits","category":"section"},{"location":"tutorial/#Modular-Arithmetic-(ZZ_p)","page":"Tutorial","title":"Modular Arithmetic (ZZ_p)","text":"using LibNTL\n\n# Set the modulus (must be > 1)\np = ZZ(17)\nZZ_p_init!(p)\n\n# Create elements mod p\nx = ZZ_p(5)\ny = ZZ_p(12)\n\n# Arithmetic (automatically reduced mod p)\nsum = x + y      # 0 (since 5 + 12 = 17 ≡ 0 mod 17)\nprod = x * y     # 9 (since 5 * 12 = 60 ≡ 9 mod 17)\n\n# Inverse\ninv_x = inv(x)   # 7 (since 5 * 7 = 35 ≡ 1 mod 17)\n\n# Power\npowered = x^10\n\n# Get underlying value\nval = rep(x)     # Returns ZZ in [0, p-1]\n\n# Check current modulus\nprintln(\"Modulus: \", ZZ_p_modulus())  # 17","category":"section"},{"location":"tutorial/#Context-Switching","page":"Tutorial","title":"Context Switching","text":"using LibNTL\n\n# Work with different moduli\nZZ_p_init!(ZZ(17))\na = ZZ_p(5)\n\n# Use with_modulus for temporary modulus change\nresult = with_modulus(ZZ(23)) do\n    b = ZZ_p(7)\n    inv(b)  # Inverse mod 23\nend\n\n# Original modulus is restored\nprintln(ZZ_p_modulus())  # 17","category":"section"},{"location":"tutorial/#Polynomials-over-Z-(ZZX)","page":"Tutorial","title":"Polynomials over Z (ZZX)","text":"using LibNTL\n\n# Create polynomials\nzero_poly = ZZX()              # 0\nconst_poly = ZZX(ZZ(5))        # 5\nlinear = ZZX([ZZ(1), ZZ(2)])   # 1 + 2x\n\n# Build polynomial by setting coefficients\nf = ZZX()\nsetcoeff!(f, 0, ZZ(1))   # constant term\nsetcoeff!(f, 2, ZZ(3))   # x^2 coefficient\nsetcoeff!(f, 4, ZZ(1))   # x^4 coefficient\n# f = 1 + 3x^2 + x^4\n\n# Query polynomial\nprintln(\"Degree: \", degree(f))        # 4\nprintln(\"Leading: \", leading(f))      # 1\nprintln(\"Constant: \", constant(f))    # 1\nprintln(\"Coeff of x^2: \", coeff(f, 2)) # 3\nprintln(\"Coeff of x^3: \", coeff(f, 3)) # 0 (not set)\n\n# Arithmetic\ng = ZZX([ZZ(1), ZZ(1)])  # 1 + x\nproduct = f * g\nsum = f + g\n\n# Division\nq, r = divrem(f, g)  # f = q*g + r\n\n# GCD\nh = gcd(f, g)\n\n# Evaluate polynomial\nx = ZZ(2)\nresult = f(x)  # 1 + 3*4 + 16 = 29\n\n# Derivative\ndf = derivative(f)  # 6x + 4x^3\n\n# Content and primitive part\nc = content(f)      # GCD of coefficients\npp = primpart(f)    # f / content(f)","category":"section"},{"location":"tutorial/#Common-Patterns","page":"Tutorial","title":"Common Patterns","text":"","category":"section"},{"location":"tutorial/#RSA-style-Modular-Exponentiation","page":"Tutorial","title":"RSA-style Modular Exponentiation","text":"using LibNTL\n\n# Generate a prime modulus\np = ZZ(\"104729\")  # A prime number\n\nZZ_p_init!(p)\n\n# Base and exponent\nbase = ZZ_p(12345)\nexponent = ZZ(\"1000000007\")\n\n# Modular exponentiation\nresult = base^exponent\n\nprintln(\"12345^1000000007 mod 104729 = \", rep(result))","category":"section"},{"location":"tutorial/#Polynomial-GCD","page":"Tutorial","title":"Polynomial GCD","text":"using LibNTL\n\n# f(x) = x^3 - 1 = (x-1)(x^2+x+1)\nf = ZZX([ZZ(-1), ZZ(0), ZZ(0), ZZ(1)])\n\n# g(x) = x^2 - 1 = (x-1)(x+1)\ng = ZZX([ZZ(-1), ZZ(0), ZZ(1)])\n\n# GCD should be (x-1) up to constant\nh = gcd(f, g)\nprintln(\"GCD: \", h)  # Should be proportional to (x - 1)","category":"section"},{"location":"tutorial/#Large-Integer-Factorization-Setup","page":"Tutorial","title":"Large Integer Factorization Setup","text":"using LibNTL\n\n# Check if a number might be prime\nn = ZZ(\"170141183460469231731687303715884105727\")  # 2^127 - 1 (Mersenne prime)\n\n# Count bits\nprintln(\"Bits: \", numbits(n))  # 127\n\n# Basic primality test via trial division up to small bound\nis_composite = false\nfor p in [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]\n    if rem(n, ZZ(p)) == ZZ(0) && n != ZZ(p)\n        is_composite = true\n        println(\"Divisible by \", p)\n        break\n    end\nend\n\nif !is_composite\n    println(\"Not divisible by small primes\")\nend","category":"section"},{"location":"tutorial/#Error-Handling","page":"Tutorial","title":"Error Handling","text":"using LibNTL\n\n# Division by zero\ntry\n    div(ZZ(10), ZZ(0))\ncatch e\n    println(\"Caught: \", e)  # DomainError\nend\n\n# Inverse of zero in ZZ_p\nZZ_p_init!(ZZ(17))\ntry\n    inv(ZZ_p(0))\ncatch e::InvModError\n    println(\"Cannot invert \", e.a, \" mod \", e.n)\nend","category":"section"},{"location":"tutorial/#Performance-Tips","page":"Tutorial","title":"Performance Tips","text":"Reuse objects: Avoid creating many small temporary ZZ values in tight loops\nPre-set modulus: Call ZZ_p_init! once before many ZZ_p operations\nUse with_modulus: For nested computations with different moduli\nPolynomial degree: Higher degree polynomials use FFT-based multiplication","category":"section"},{"location":"tutorial/#Vectors-and-Matrices","page":"Tutorial","title":"Vectors and Matrices","text":"","category":"section"},{"location":"tutorial/#VecZZ-Vectors-of-Integers","page":"Tutorial","title":"VecZZ - Vectors of Integers","text":"using LibNTL\n\n# Create a vector\nv = VecZZ([ZZ(1), ZZ(2), ZZ(3), ZZ(4), ZZ(5)])\n\n# 1-indexed access (Julia style)\nprintln(v[1])  # 1\n\n# 0-indexed access (NTL style)\nprintln(v(0))  # 1\n\n# Iteration\nfor x in v\n    println(x)\nend\n\n# Modification\nv[1] = ZZ(100)","category":"section"},{"location":"tutorial/#MatZZ-Matrices-of-Integers","page":"Tutorial","title":"MatZZ - Matrices of Integers","text":"using LibNTL\n\n# Create a 2x2 matrix\nA = MatZZ(2, 2)\nA[1,1] = ZZ(1); A[1,2] = ZZ(2)\nA[2,1] = ZZ(3); A[2,2] = ZZ(4)\n\n# Dimensions\nprintln(\"Rows: \", nrows(A))\nprintln(\"Cols: \", ncols(A))\n\n# Matrix multiplication\nB = MatZZ(2, 2)\nB[1,1] = ZZ(5); B[1,2] = ZZ(6)\nB[2,1] = ZZ(7); B[2,2] = ZZ(8)\n\nC = A * B\nprintln(C[1,1])  # 19","category":"section"},{"location":"tutorial/#Modular-Polynomials-(ZZ_pX)","page":"Tutorial","title":"Modular Polynomials (ZZ_pX)","text":"using LibNTL\n\n# Set modulus first\nwith_modulus(ZZ(17)) do\n    # Create polynomial: 1 + 2x + 3x^2\n    f = ZZ_pX([ZZ_p(1), ZZ_p(2), ZZ_p(3)])\n\n    # Degree and coefficients\n    println(\"Degree: \", degree(f))\n    println(\"Leading coeff: \", leading(f))\n\n    # Arithmetic\n    g = ZZ_pX([ZZ_p(1), ZZ_p(1)])  # 1 + x\n    println(\"f + g = \", f + g)\n    println(\"f * g = \", f * g)\n\n    # Division\n    q, r = divrem(f, g)\n    println(\"f / g = \", q, \" remainder \", r)\n\n    # GCD\n    h = gcd(f, g)\n    println(\"gcd(f, g) = \", h)\n\n    # Irreducibility testing\n    irred = ZZ_pX([ZZ_p(1), ZZ_p(1), ZZ_p(1)])  # x^2 + x + 1\n    println(\"x^2 + x + 1 irreducible mod 17: \", is_irreducible(irred))\nend","category":"section"},{"location":"tutorial/#Polynomial-Factorization","page":"Tutorial","title":"Polynomial Factorization","text":"using LibNTL\n\n# Factor x^4 - 1 over Z\nf = ZZX([ZZ(-1), ZZ(0), ZZ(0), ZZ(0), ZZ(1)])\n\ncontent_val, factors = factor(f)\nprintln(\"Content: \", content_val)\nprintln(\"Factors:\")\nfor (poly, mult) in factors\n    println(\"  \", poly, \" ^ \", mult)\nend","category":"section"},{"location":"tutorial/#Cyclotomic-Polynomials","page":"Tutorial","title":"Cyclotomic Polynomials","text":"using LibNTL\n\n# Generate cyclotomic polynomials\nfor n in [1, 2, 3, 4, 6, 12]\n    phi = cyclotomic(n)\n    println(\"Phi_$n(x) = \", phi, \" (degree \", degree(phi), \")\")\nend","category":"section"},{"location":"tutorial/#Number-Theory-Functions","page":"Tutorial","title":"Number Theory Functions","text":"using LibNTL\n\n# Modular exponentiation\nresult = PowerMod(ZZ(2), ZZ(100), ZZ(1000000007))\nprintln(\"2^100 mod 10^9+7 = \", result)\n\n# Primality testing\nn = ZZ(\"170141183460469231731687303715884105727\")\nprintln(\"Is Mersenne prime: \", ProbPrime(n))\n\n# Random numbers\nr = RandomBnd(ZZ(1000))\nprintln(\"Random < 1000: \", r)\n\n# Bit operations\nx = ZZ(255)\nprintln(\"Bits in 255: \", numbits(x))\nprintln(\"Bit 7: \", bit(x, 7))","category":"section"},{"location":"tutorial/#Comparison-with-Julia's-BigInt","page":"Tutorial","title":"Comparison with Julia's BigInt","text":"Operation LibNTL.ZZ Julia BigInt Notes\nCreation ZZ(...) big\"...\" Similar\nArithmetic Same operators Same operators ZZ uses NTL's optimized GMP wrapper\nModular ZZ_p type mod() function ZZ_p stores modulus context\nPolynomials Native ZZX Manual ZZX has built-in polynomial ops\nVectors VecZZ Vector{BigInt} VecZZ supports 0-indexed access\nMatrices MatZZ Matrix{BigInt} MatZZ has optimized multiplication","category":"section"},{"location":"types/#Type-Reference","page":"Types","title":"Type Reference","text":"","category":"section"},{"location":"types/#ZZ-Arbitrary-Precision-Integers","page":"Types","title":"ZZ - Arbitrary-Precision Integers","text":"","category":"section"},{"location":"types/#Arithmetic","page":"Types","title":"Arithmetic","text":"ZZ supports all standard Julia arithmetic operators:\n\n+, -, *: Addition, subtraction, multiplication\n^: Power (non-negative integer exponents)\ndiv, rem, mod, divrem: Integer division operations\ngcd, gcdx: GCD and extended GCD","category":"section"},{"location":"types/#Conversion","page":"Types","title":"Conversion","text":"# From various types\nZZ(42)                    # From Int\nZZ(\"12345678901234567890\")  # From String\nZZ(big\"999999999999\")     # From BigInt\n\n# To other types\nBigInt(ZZ(42))            # To BigInt\nconvert(Int64, ZZ(42))    # To Int64 (throws if overflow)\nstring(ZZ(42))            # To String","category":"section"},{"location":"types/#Predicates","page":"Types","title":"Predicates","text":"iszero(z): Check if zero\nisone(z): Check if one\nisodd(z), iseven(z): Parity checks\nsign(z): Returns -1, 0, or 1","category":"section"},{"location":"types/#ZZ_p-Modular-Integers","page":"Types","title":"ZZ_p - Modular Integers","text":"","category":"section"},{"location":"types/#Modulus-Management","page":"Types","title":"Modulus Management","text":"Before using ZZ_p, you must set a modulus:\n\nZZ_p_init!(ZZ(17))  # All operations are now mod 17\n\nFor temporary modulus changes:\n\nwith_modulus(ZZ(23)) do\n    # Operations here use modulus 23\n    a = ZZ_p(20)\n    println(rep(a))  # 20\nend\n# Original modulus is restored","category":"section"},{"location":"types/#Arithmetic-2","page":"Types","title":"Arithmetic","text":"ZZ_p supports:\n\n+, -, *: Field operations\n/: Division (via multiplicative inverse)\n^: Power\ninv: Multiplicative inverse","category":"section"},{"location":"types/#ZZ_pContext","page":"Types","title":"ZZ_pContext","text":"For manual context management:\n\nctx = ZZ_pContext()\nsave!(ctx)        # Save current modulus\nZZ_p_init!(ZZ(31))  # Change modulus\n# ... work with modulus 31 ...\nrestore!(ctx)     # Restore previous modulus","category":"section"},{"location":"types/#ZZX-Polynomials-over-Z","page":"Types","title":"ZZX - Polynomials over Z","text":"","category":"section"},{"location":"types/#Construction","page":"Types","title":"Construction","text":"# From coefficient vector [a_0, a_1, ..., a_n]\nf = ZZX([ZZ(1), ZZ(2), ZZ(3)])  # 1 + 2x + 3x^2\n\n# From scalar (constant polynomial)\ng = ZZX(ZZ(5))  # 5\n\n# Zero polynomial\nh = ZZX()","category":"section"},{"location":"types/#Coefficient-Access","page":"Types","title":"Coefficient Access","text":"f = ZZX([ZZ(1), ZZ(2), ZZ(3)])\ndegree(f)     # 2\nf[0]          # ZZ(1) - constant term\nf[2]          # ZZ(3) - leading coefficient\nleading(f)    # ZZ(3)\nconstant(f)   # ZZ(1)","category":"section"},{"location":"types/#Arithmetic-3","page":"Types","title":"Arithmetic","text":"+, -, *: Polynomial arithmetic\nc * f, f * c: Scalar multiplication\ndiv, rem, divrem: Polynomial division\ngcd: Polynomial GCD","category":"section"},{"location":"types/#Polynomial-Operations","page":"Types","title":"Polynomial Operations","text":"f = ZZX([ZZ(1), ZZ(2), ZZ(3)])\n\n# Evaluation\nf(ZZ(5))  # Evaluate at x = 5\n\n# Derivative\nderivative(f)  # 2 + 6x\n\n# Content and primitive part\ng = ZZX([ZZ(6), ZZ(12), ZZ(18)])\ncontent(g)   # ZZ(6)\nprimpart(g)  # 1 + 2x + 3x^2","category":"section"},{"location":"types/#Iteration","page":"Types","title":"Iteration","text":"ZZX supports iteration over coefficients:\n\nf = ZZX([ZZ(1), ZZ(2), ZZ(3)])\nfor c in f\n    println(c)\nend\n# Output: 1, 2, 3","category":"section"},{"location":"types/#ZZ_pX-Polynomials-over-Z/pZ","page":"Types","title":"ZZ_pX - Polynomials over Z/pZ","text":"","category":"section"},{"location":"types/#Construction-2","page":"Types","title":"Construction","text":"ZZ_p_init!(ZZ(17))  # Set modulus first\nf = ZZ_pX([ZZ_p(1), ZZ_p(2), ZZ_p(3)])  # 1 + 2x + 3x^2 mod 17","category":"section"},{"location":"types/#Operations","page":"Types","title":"Operations","text":"ZZ_pX supports:\n\n+, -, *: Polynomial arithmetic mod p\ndiv, rem, divrem: Polynomial division\ngcd: Polynomial GCD (returns monic)\nis_irreducible: Test irreducibility","category":"section"},{"location":"types/#VecZZ-Vectors-of-Integers","page":"Types","title":"VecZZ - Vectors of Integers","text":"","category":"section"},{"location":"types/#Construction-3","page":"Types","title":"Construction","text":"v = VecZZ(5)  # Vector of 5 zeros\nv = VecZZ([ZZ(1), ZZ(2), ZZ(3)])  # From coefficient array","category":"section"},{"location":"types/#Indexing","page":"Types","title":"Indexing","text":"VecZZ supports both 0-indexed and 1-indexed access:\n\nv = VecZZ([ZZ(10), ZZ(20), ZZ(30)])\nv[1]   # 10 (1-indexed)\nv(0)   # 10 (0-indexed, callable syntax)","category":"section"},{"location":"types/#MatZZ-Matrices-of-Integers","page":"Types","title":"MatZZ - Matrices of Integers","text":"","category":"section"},{"location":"types/#Construction-4","page":"Types","title":"Construction","text":"M = MatZZ(3, 3)  # 3x3 zero matrix","category":"section"},{"location":"types/#Operations-2","page":"Types","title":"Operations","text":"A = MatZZ(2, 2)\nA[1,1] = ZZ(1); A[1,2] = ZZ(2)\nA[2,1] = ZZ(3); A[2,2] = ZZ(4)\n\nnrows(A)  # 2\nncols(A)  # 2","category":"section"},{"location":"types/#Number-Theory-Functions","page":"Types","title":"Number Theory Functions","text":"","category":"section"},{"location":"types/#Polynomial-Functions","page":"Types","title":"Polynomial Functions","text":"","category":"section"},{"location":"types/#InvModError","page":"Types","title":"InvModError","text":"Thrown when computing a modular inverse fails:\n\nZZ_p_init!(ZZ(10))\ntry\n    inv(ZZ_p(5))  # 5 has no inverse mod 10\ncatch e::InvModError\n    println(\"Cannot invert \", e.a, \" mod \", e.n)\nend","category":"section"},{"location":"types/#LibNTL.ZZ","page":"Types","title":"LibNTL.ZZ","text":"ZZ\n\nArbitrary-precision integer type. In development mode, this is a wrapper around BigInt.\n\n\n\n\n\n","category":"type"},{"location":"types/#LibNTL.numbits","page":"Types","title":"LibNTL.numbits","text":"numbits(z::ZZ) -> Int\n\nReturn the number of bits in the binary representation of |z|. Returns 0 for z = 0.\n\n\n\n\n\n","category":"function"},{"location":"types/#LibNTL.numbytes","page":"Types","title":"LibNTL.numbytes","text":"numbytes(z::ZZ) -> Int\n\nReturn the number of bytes needed to represent |z|. Returns 0 for z = 0.\n\n\n\n\n\n","category":"function"},{"location":"types/#LibNTL.ZZ_p","page":"Types","title":"LibNTL.ZZ_p","text":"ZZ_p\n\nModular integer type. In development mode, this is a wrapper around ZZ.\n\n\n\n\n\n","category":"type"},{"location":"types/#LibNTL.ZZ_p_init!","page":"Types","title":"LibNTL.ZZ_p_init!","text":"ZZ_p_init!(p::ZZ)\n\nSet the global modulus for ZZ_p operations. Throws DomainError if p <= 1.\n\n\n\n\n\n","category":"function"},{"location":"types/#LibNTL.ZZ_p_modulus","page":"Types","title":"LibNTL.ZZ_p_modulus","text":"ZZ_p_modulus() -> ZZ\n\nReturn the current global modulus for ZZ_p operations.\n\n\n\n\n\n","category":"function"},{"location":"types/#LibNTL.with_modulus","page":"Types","title":"LibNTL.with_modulus","text":"with_modulus(f::Function, p::ZZ)\n\nExecute function f with a temporary modulus p. The original modulus is restored after f completes.\n\n\n\n\n\n","category":"function"},{"location":"types/#LibNTL.rep","page":"Types","title":"LibNTL.rep","text":"rep(a::ZZ_p) -> ZZ\n\nGet the representative integer in [0, p-1] for a ZZ_p value.\n\n\n\n\n\n","category":"function"},{"location":"types/#LibNTL.save!","page":"Types","title":"LibNTL.save!","text":"save!(ctx::ZZ_pContext)\n\nSave the current modulus state into the context.\n\n\n\n\n\n","category":"function"},{"location":"types/#LibNTL.restore!","page":"Types","title":"LibNTL.restore!","text":"restore!(ctx::ZZ_pContext)\n\nRestore the modulus state from the context.\n\n\n\n\n\n","category":"function"},{"location":"types/#LibNTL.ZZ_pContext","page":"Types","title":"LibNTL.ZZ_pContext","text":"ZZ_pContext\n\nContext for saving/restoring ZZ_p modulus state.\n\n\n\n\n\n","category":"type"},{"location":"types/#LibNTL.ZZX","page":"Types","title":"LibNTL.ZZX","text":"ZZX\n\nPolynomial over integers. In development mode, stores coefficients as Vector{ZZ}.\n\n\n\n\n\n","category":"type"},{"location":"types/#LibNTL.degree","page":"Types","title":"LibNTL.degree","text":"degree(f::ZZX) -> Int\n\nReturn the degree of the polynomial. Returns -1 for the zero polynomial.\n\n\n\n\n\ndegree(f::ZZ_pX) -> Int\n\nReturn the degree of the polynomial. Returns -1 for the zero polynomial.\n\n\n\n\n\ndegree(f::GF2X) -> Int\n\nReturn the degree of the polynomial. Returns -1 for the zero polynomial.\n\n\n\n\n\n","category":"function"},{"location":"types/#LibNTL.coeff","page":"Types","title":"LibNTL.coeff","text":"coeff(f::ZZX, i::Integer) -> ZZ\n\nReturn the coefficient of x^i in f.\n\n\n\n\n\ncoeff(f::ZZ_pX, i::Integer) -> ZZ_p\n\nReturn the coefficient of x^i in f.\n\n\n\n\n\ncoeff(f::GF2X, i::Integer) -> GF2\n\nReturn the coefficient of x^i in f.\n\n\n\n\n\n","category":"function"},{"location":"types/#LibNTL.setcoeff!","page":"Types","title":"LibNTL.setcoeff!","text":"setcoeff!(f::ZZX, i::Integer, c::ZZ)\n\nSet the coefficient of x^i in f to c.\n\n\n\n\n\nsetcoeff!(f::ZZ_pX, i::Integer, c::ZZ_p)\n\nSet the coefficient of x^i in f to c.\n\n\n\n\n\nsetcoeff!(f::GF2X, i::Integer, c::GF2)\n\nSet the coefficient of x^i in f to c.\n\n\n\n\n\n","category":"function"},{"location":"types/#LibNTL.leading","page":"Types","title":"LibNTL.leading","text":"leading(f::ZZX) -> ZZ\n\nReturn the leading (highest degree) coefficient of f.\n\n\n\n\n\nleading(f::ZZ_pX) -> ZZ_p\n\nReturn the leading (highest degree) coefficient of f.\n\n\n\n\n\nleading(f::GF2X) -> GF2\n\nReturn the leading (highest degree) coefficient of f.\n\n\n\n\n\n","category":"function"},{"location":"types/#LibNTL.constant","page":"Types","title":"LibNTL.constant","text":"constant(f::ZZX) -> ZZ\n\nReturn the constant term (coefficient of x^0) of f.\n\n\n\n\n\nconstant(f::ZZ_pX) -> ZZ_p\n\nReturn the constant term (coefficient of x^0) of f.\n\n\n\n\n\nconstant(f::GF2X) -> GF2\n\nReturn the constant term (coefficient of x^0) of f.\n\n\n\n\n\n","category":"function"},{"location":"types/#LibNTL.derivative","page":"Types","title":"LibNTL.derivative","text":"derivative(f::ZZX) -> ZZX\n\nCompute the formal derivative of f.\n\n\n\n\n\nderivative(f::ZZ_pX) -> ZZ_pX\n\nCompute the formal derivative of f.\n\n\n\n\n\nderivative(f::GF2X) -> GF2X\n\nCompute the formal derivative of f.\n\n\n\n\n\n","category":"function"},{"location":"types/#LibNTL.content","page":"Types","title":"LibNTL.content","text":"content(f::ZZX) -> ZZ\n\nCompute the content (GCD of all coefficients) of f.\n\n\n\n\n\n","category":"function"},{"location":"types/#LibNTL.primpart","page":"Types","title":"LibNTL.primpart","text":"primpart(f::ZZX) -> ZZX\n\nCompute the primitive part (f / content(f)) of f.\n\n\n\n\n\n","category":"function"},{"location":"types/#LibNTL.ZZ_pX","page":"Types","title":"LibNTL.ZZ_pX","text":"ZZ_pX\n\nPolynomial over Z/pZ. In development mode, stores coefficients as Vector{ZZp}. Operations are performed modulo the current ZZp modulus.\n\n\n\n\n\n","category":"type"},{"location":"types/#LibNTL.is_irreducible","page":"Types","title":"LibNTL.is_irreducible","text":"is_irreducible(f::ZZ_pX) -> Bool\n\nTest if the polynomial f is irreducible over the current modulus.\n\n\n\n\n\nis_irreducible(f::GF2X) -> Bool\n\nTest if the polynomial f is irreducible over GF(2).\n\n\n\n\n\n","category":"function"},{"location":"types/#LibNTL.VecZZ","page":"Types","title":"LibNTL.VecZZ","text":"VecZZ\n\nVector of arbitrary-precision integers. In development mode, this is a wrapper around Vector{ZZ}.\n\n\n\n\n\n","category":"type"},{"location":"types/#LibNTL.MatZZ","page":"Types","title":"LibNTL.MatZZ","text":"MatZZ\n\nMatrix of arbitrary-precision integers. In development mode, this is a wrapper around Matrix{ZZ}.\n\n\n\n\n\n","category":"type"},{"location":"types/#LibNTL.PowerMod","page":"Types","title":"LibNTL.PowerMod","text":"PowerMod(a::ZZ, e::ZZ, n::ZZ) -> ZZ\n\nCompute a^e mod n using binary exponentiation.\n\nArguments\n\na: Base\ne: Exponent (can be negative if a is invertible mod n)\nn: Modulus (must be > 1)\n\nReturns\n\nResult in range [0, n-1]\n\nExamples\n\nPowerMod(ZZ(2), ZZ(10), ZZ(1000))  # 2^10 mod 1000 = 24\nPowerMod(ZZ(3), ZZ(-1), ZZ(7))     # 3^(-1) mod 7 = 5\n\nErrors\n\nThrows DomainError if n <= 1\n\n\n\n\n\n","category":"function"},{"location":"types/#LibNTL.ProbPrime","page":"Types","title":"LibNTL.ProbPrime","text":"ProbPrime(n::ZZ, num_trials::Int=10) -> Bool\n\nProbabilistic primality test using Miller-Rabin.\n\nArguments\n\nn: Number to test\nnum_trials: Number of Miller-Rabin iterations (default: 10)\n\nReturns\n\ntrue if n is probably prime\nfalse if n is definitely composite\n\nExamples\n\nProbPrime(ZZ(1000000007))      # true\nProbPrime(ZZ(1000000007), 20)  # true with more confidence\nProbPrime(ZZ(100))              # false\n\n\n\n\n\n","category":"function"},{"location":"types/#LibNTL.RandomBnd","page":"Types","title":"LibNTL.RandomBnd","text":"RandomBnd(n::ZZ) -> ZZ\n\nReturn a random integer in [0, n-1]. Requires n > 0.\n\n\n\n\n\n","category":"function"},{"location":"types/#LibNTL.RandomBits","page":"Types","title":"LibNTL.RandomBits","text":"RandomBits(n::Int) -> ZZ\n\nReturn a random n-bit integer. The result is in [0, 2^n - 1].\n\n\n\n\n\n","category":"function"},{"location":"types/#LibNTL.bit","page":"Types","title":"LibNTL.bit","text":"bit(a::ZZ, i::Int) -> Int\n\nReturn bit i of |a| (0-indexed from least significant). Returns 0 if i >= numbits(a).\n\nExamples\n\nbit(ZZ(5), 0)  # 1 (5 = 101 in binary)\nbit(ZZ(5), 1)  # 0\nbit(ZZ(5), 2)  # 1\n\n\n\n\n\n","category":"function"},{"location":"types/#LibNTL.factor","page":"Types","title":"LibNTL.factor","text":"factor(f::ZZX) -> (ZZ, Vector{Tuple{ZZX, Int}})\n\nFactor the polynomial f over the integers.\n\nReturns a tuple (content, factors) where:\n\ncontent is the content of f (GCD of all coefficients)\nfactors is a vector of (factor, multiplicity) pairs\n\nThe product of content times all factors raised to their multiplicities equals f.\n\nExample\n\nf = ZZX([ZZ(-1), ZZ(0), ZZ(1)])  # x^2 - 1\nc, factors = factor(f)\n# c = 1, factors = [(x-1, 1), (x+1, 1)]\n\n\n\n\n\n","category":"function"},{"location":"types/#LibNTL.cyclotomic","page":"Types","title":"LibNTL.cyclotomic","text":"cyclotomic(n::Integer) -> ZZX\n\nCompute the n-th cyclotomic polynomial Φₙ(x).\n\nThe cyclotomic polynomial Φₙ(x) is the minimal polynomial of primitive n-th roots of unity over the rationals. It satisfies:\n\nxⁿ - 1 = ∏{d|n} Φd(x)\ndegree(Φₙ) = φ(n) (Euler's totient function)\n\nExamples\n\ncyclotomic(1)   # x - 1\ncyclotomic(2)   # x + 1\ncyclotomic(3)   # x² + x + 1\ncyclotomic(4)   # x² + 1\ncyclotomic(6)   # x² - x + 1\n\n\n\n\n\n","category":"function"},{"location":"types/#LibNTL.InvModError","page":"Types","title":"LibNTL.InvModError","text":"InvModError(a::Any, n::Any)\n\nException thrown when computing a modular inverse fails because gcd(a, n) ≠ 1.\n\nFields\n\na: The value that failed to be inverted\nn: The modulus\n\nExample\n\ntry\n    inv(ZZ_p(0))\ncatch e::InvModError\n    println(\"Cannot invert \", e.a, \" mod \", e.n)\nend\n\n\n\n\n\n","category":"type"}]
}
